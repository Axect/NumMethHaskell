% Hacking on GHC
% Dominic Steinitz
% 14th February 2017

One of my colleagues pointed out that the code generated by ghc for
floating point *abs* was about 20 instructions when targetting the X86
instruction set and that there was a single instruction available on
the floating point co-processor.

In fact floating point *abs* was discussed sometime ago on the
ghc-dev(?) mailing list. The original Haskell code which handled
floating point *abs* did not handle negative zero (-0.0) correctly. It
was noted here that more efficient code could be generated but as so
often with pious hopes this was never implemented.

I wanted to capture the wrong paths I took as well as the final result
as I learnt as much from my failures as from my ultimate success.

* C code to see what gets generated

* clang and gcc

* same as sqrt presumably carried out on co-processor

* want to drop X87 support

* X86 and llvm but what about the others? cmm

* Getting the benefit of e.g. polly is going to be very difficult but
could use EDSL like accelerate. See the links in Trevor's emails maybe?

The Haskell:

~~~~ {include="HaskellFunction.hs"}
~~~~

The .cabal:

~~~~ {include="../test-via-c.cabal"}
~~~~

On my computer running

    cabal install

places the library in

    ~/Library/Haskell/ghc-8.0.1/lib/test-via-c-0.1.0.0/bin

The C:

~~~~ {include="MainC.c"}
~~~~

On my computer this can be compiled with

    gcc-6 Bar.c
    ~/Library/Haskell/ghc-8.0.1/lib/test-via-c-0.1.0.0/bin/Foo.dylib
    -I/Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/lib/ghc-8.0.1/include
    -L/Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/lib/ghc-8.0.1/rts
    -lHSrts-ghc8.0.1

and can be run with

    DYLD_LIBRARY_PATH=
    ~/Library/Haskell/ghc-8.0.1/lib/test-via-c-0.1.0.0/bin:
    /Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/lib/ghc-8.0.1/rts

